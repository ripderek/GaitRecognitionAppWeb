<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Identificaci√≥n</title>
  <link href="static/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body { 
      font-family: Arial, sans-serif; 
      background-color: #f8f9fa;
      margin: 0;       /* <- elimina m√°rgenes del body */
      padding: 0;      /* <- elimina padding para que el navbar llegue al borde */
    }
    #container {
      position: relative;
      width: 100%;
      height: auto;
      max-width: 960px;
      margin: 0 auto;  /* centra el video en la p√°gina */
      padding: 10px;   /* margen interno opcional */
    }
    #videoStream {
      display: block;
      width: 100%;
      height: auto;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    #videoCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #infoPanel {
      font-size: 14px;
    }
    /* Nuevo: contenedor para el gr√°fico de vectores */
    #vectorChartContainer {
      max-width: 960px;
      margin: 20px auto;
    }
  </style>

</head>
<body>
  {% include 'navbar.html' %}
  <div class="container-fluid">
    <h1 class="text-center mb-4">üé• Muestras personas</h1>
    <div class="row">
      <!-- Columna izquierda: Video -->
      <div class="col-md-7">
        <div id="container" class="mb-3">
          <img id="videoStream" src="/video_feed_m" alt="Stream de Video">
          <!-- canvas sin width/height fijos, se ajusta din√°micamente -->
          <canvas id="videoCanvas"></canvas>
        </div>
        <div>
          <button onclick="toggleStream('play')">‚ñ∂Ô∏è Reanudar</button>
          <button onclick="toggleStream('pause')">‚è∏Ô∏è Pausar</button>
          <button onclick="restartStream()">üîÑ Reiniciar</button>
        </div>
        <div class="form-check">
          <input class="form-check-input" type="checkbox" id="saveSamplesCheckbox" checked> 
          <label class="form-check-label" for="saveSamplesCheckbox">
          Guardar muestras en tiempo real
          </label>
          </div>
          <div class="form-check">
          <input class="form-check-input" type="checkbox" id="saveSamplesCheckbox_samples" checked>
          <label class="form-check-label" for="saveSamplesCheckbox_samples">
          Muestras para entrenamiento
          </label>
          </div>
      </div>

      <!-- Columna derecha: Panel de info -->
      <div class="col-md-5">
        <div class="card shadow-sm">
          <div class="card-header bg-primary text-white">
            Informaci√≥n del Detector
          </div>
          <div class="card-body">
            <!-- Aqu√≠ se inyecta la info del panel -->
            <div id="infoPanel" class="table-responsive">
              <p class="text-muted">Esperando datos...</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Nuevo: contenedor para el gr√°fico de vectores -->
  <div id="vectorChartContainer">
    <canvas id="vectorChart"></canvas>
  </div>

  <!-- Scripts originales -->
  <script>
    const canvas = document.getElementById('videoCanvas');
    const ctx = canvas.getContext('2d');
    const img = document.getElementById('videoStream');

    let personas = [];
    window.selectedId = null;

    // üîπ Ajustar tama√±o del canvas al del video
    function resizeCanvas() {
      canvas.width = img.clientWidth;
      canvas.height = img.clientHeight;
    }

    // üîπ Ejecutar cuando se cargue el video y cuando cambie el tama√±o de ventana
    img.onload = resizeCanvas;
    window.addEventListener('resize', resizeCanvas);

    // Dibujar cajas encima del video
    function drawBoxes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Escalas respecto al tama√±o original del video en OpenCV (960x540)
      const scaleX = canvas.width / 960;
      const scaleY = canvas.height / 540;

      personas.forEach(({tid, box}) => {
        let [x1, y1, x2, y2] = box;

        // üîπ Escalar coordenadas al tama√±o actual del canvas
        x1 *= scaleX;
        x2 *= scaleX;
        y1 *= scaleY;
        y2 *= scaleY;

        ctx.strokeStyle = (tid === window.selectedId) ? 'red' : 'green';
        ctx.lineWidth = 2;
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

        ctx.fillStyle = ctx.strokeStyle;
        ctx.font = '16px Arial';
        //ctx.fillText(`ID ${tid}`, x1, y1 - 5);
      });

      requestAnimationFrame(drawBoxes);
    }

    drawBoxes(); // iniciar loop de dibujo

    // Actualizar detecciones cada 100ms
    setInterval(async () => {
      try {
        const res = await fetch('/get_detections_m');
        personas = await res.json();
      } catch (e) {
        console.error('Error al obtener detecciones:', e);
      }
    }, 100);

    // Manejar clicks sobre canvas
    canvas.addEventListener('click', function(e) {
      const rect = canvas.getBoundingClientRect();

      // üîπ Escalas respecto al tama√±o original del video en OpenCV (960x540)
      const scaleX = 960 / canvas.width;
      const scaleY = 540 / canvas.height;

      // Coordenadas del click dentro del canvas
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;

      for (let i = 0; i < personas.length; i++) {
        const {tid, box} = personas[i];
        const [x1, y1, x2, y2] = box;
        if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {
          fetch('/select_person_m', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ tid })
          })
          .then(res => res.json())
          .then(data => { 
            console.log('Seleccion actualizada:', data);
            window.selectedId = tid; 
          });
          break;
        }
      }
    });
  </script>
  <script>
    let infoDetector = {};

    // Actualizar info extra cada 1s
    setInterval(async () => {
      try {
        const res = await fetch('/get_info_m');
        infoDetector = await res.json();
        renderInfo(infoDetector);
        renderVectorChart(infoDetector); // üîπ actualizar gr√°fico
      } catch (e) {
        console.error('Error al obtener info extra:', e);
      }
    }, 5000);

    // Mostrar info en pantalla
    function renderInfo(info) {
      let panel = document.getElementById('infoPanel');
      panel.innerHTML = `
        <table class="table table-sm table-bordered align-middle">
          <tbody>
            <tr><th>Orientaci√≥n</th><td>${info.orientacionString}</td></tr>
            <tr><th>Guardado</th><td>${info.muestras_estado}</td></tr>
            <tr><th>Muestras</th><td>${info.muestras_tipo}</td></tr>
          </tbody>
        </table>
      `;
    }

    // üîπ Configuraci√≥n del gr√°fico de vectores
    const vectorCtx = document.getElementById('vectorChart').getContext('2d');
    const vectorChart = new Chart(vectorCtx, {
      type: 'line',
      data: {
        labels: [], // √≠ndices de secuencia
        datasets: [
          { label: '32-31', data: [], borderColor: 'red', fill: false },
          { label: '28-27', data: [], borderColor: 'blue', fill: false }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        scales: {
          x: { title: { display: true, text: 'Frame' } },
          y: { title: { display: true, text: 'Distancia' } }
        }
      }
    });

    // üîπ Funci√≥n para actualizar gr√°fico con los vectores
    function renderVectorChart(info) {
      vectorChart.data.labels = info.vector_distancia_32_31?.map((_, i) => i) || [];
      vectorChart.data.datasets[0].data = info.vector_distancia_32_31 || [];
      vectorChart.data.datasets[1].data = info.vector_distancia_28_27 || [];
      vectorChart.update();
    }

  </script>
  <script>
  function toggleStream(action) {
    fetch('/toggle_stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action })
    })
    .then(res => res.json())
    .then(data => console.log('Streaming:', data));
  }
  function restartStream() {
    fetch('/restart_stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    })
    .then(res => res.json())
    .then(data => console.log(data.message));
  }

  //para guardar las muestras 
  const checkbox = document.getElementById('saveSamplesCheckbox');

  checkbox.addEventListener('change', function() {
    const saveEnabled = checkbox.checked; // true si est√° marcado, false si no
    fetch('/toggle_save_samples', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ save: saveEnabled })
    })
    .then(res => res.json())
    .then(data => console.log('Guardar muestras:', data.save));
    });

    //para cambiar el tipo de muestras entre entrenamiento o prueba
     const checkbox_samples = document.getElementById('saveSamplesCheckbox_samples');

  checkbox_samples.addEventListener('change', function() {
    const saveEnabled = checkbox_samples.checked; // true si est√° marcado, false si no
    fetch('/toggle_train_samples', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ save: saveEnabled })
    })
    .then(res => res.json())
    .then(data => console.log('Tipo de muestras:', data.save));
    });

</script>

</body>
</html>
